// ikootaapi/controllers/classControllers.js
// COMPLETE REBUILD USING EXACT MEMBERSHIP CONTROLLER PATTERNS
// Simple try-catch, direct service calls, consistent response format

import classService from '../services/classServices.js';
// import * as liveClassService from '../services/liveClassSchedulingServices.js'; // MERGED INTO classServices.js

// =============================================================================
// UTILITY FUNCTIONS (FOLLOWING MEMBERSHIP PATTERN)
// =============================================================================

/**
 * Standardized success response
 */
const successResponse = (res, data = {}, message = 'Operation successful', statusCode = 200) => {
  return res.status(statusCode).json({
    success: true,
    message,
    ...data,
    timestamp: new Date().toISOString()
  });
};

/**
 * Standardized error response
 */
const errorResponse = (res, error, statusCode = 500) => {
  console.error('Controller error:', error);
  return res.status(statusCode).json({
    success: false,
    error: error.message || 'An error occurred',
    timestamp: new Date().toISOString(),
    ...(process.env.NODE_ENV === 'development' && { 
      details: error.stack 
    })
  });
};

// =============================================================================
// CORE CLASS OPERATIONS (FOLLOWING MEMBERSHIP CONTROLLER PATTERNS)
// =============================================================================

/**
 * GET /api/classes - Get all classes
 */
export const getAllClasses = async (req, res) => {
  try {
    const userId = req.user?.id;
    const filters = {
      class_type: req.query.class_type,
      is_public: req.query.is_public === 'true' ? true : req.query.is_public === 'false' ? false : undefined,
      search: req.query.search
    };

    const options = {
      page: parseInt(req.query.page) || 1,
      limit: parseInt(req.query.limit) || 20,
      sort_by: req.query.sort_by || 'createdAt',
      sort_order: req.query.sort_order || 'DESC'
    };

    const result = await classService.getAllClasses(filters, options);
    
    return successResponse(res, result, 'Classes retrieved successfully');

  } catch (error) {
    console.error('‚ùå getAllClasses error:', error);
    return errorResponse(res, error);
  }
};

/**
 * GET /api/classes/:id - Get specific class
 */
export const getClassById = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;

    const result = await classService.getClassById(id, userId);
    
    return successResponse(res, { data: result }, 'Class retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassById error:', error);
    const statusCode = error.message.includes('not found') ? 404 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/my-classes - Get user's classes
 */
export const getUserClasses = async (req, res) => {
  try {
    const userId = req.user.id;
    const options = {
      page: parseInt(req.query.page) || 1,
      limit: parseInt(req.query.limit) || 20,
      membership_status: req.query.membership_status || 'active',
      sort_by: req.query.sort_by || 'joinedAt',
      sort_order: req.query.sort_order || 'DESC'
    };

    const result = await classService.getUserClasses(userId, options);
    
    return successResponse(res, {
      ...result,
      user_id: userId,
      username: req.user.username
    }, 'User classes retrieved successfully');

  } catch (error) {
    console.error('‚ùå getUserClasses error:', error);
    return errorResponse(res, error);
  }
};

/**
 * POST /api/classes/:id/join - Join a class
 */
export const joinClass = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const options = {
      role_in_class: req.body.role_in_class || 'member',
      receive_notifications: req.body.receive_notifications !== false
    };

    const result = await classService.joinClass(userId, id, options);
    
    return successResponse(res, {
      ...result,
      user_id: userId,
      username: req.user.username
    }, result.message, 201);

  } catch (error) {
    console.error('‚ùå joinClass error:', error);
    const statusCode = error.message.includes('not found') ? 404 :
                      error.message.includes('full') ? 409 :
                      error.message.includes('already') ? 409 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * POST /api/classes/:id/leave - Leave a class
 */
export const leaveClass = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    const result = await classService.leaveClass(userId, id);
    
    return successResponse(res, {
      ...result,
      user_id: userId,
      username: req.user.username
    }, result.message);

  } catch (error) {
    console.error('‚ùå leaveClass error:', error);
    const statusCode = error.message.includes('not found') ? 404 :
                      error.message.includes('Not a member') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/:id/members - Get class members (enhanced with mentorship data)
 */
export const getClassMembers = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const includeMentorship = req.query.include_mentorship === 'true';
    
    const options = {
      page: parseInt(req.query.page) || 1,
      limit: parseInt(req.query.limit) || 50,
      membership_status: req.query.membership_status || 'active',
      sort_by: req.query.sort_by || 'joinedAt',
      sort_order: req.query.sort_order || 'DESC'
    };

    let result;
    if (includeMentorship) {
      result = await classService.getClassMembersWithMentorship(id, userId, options);
    } else {
      result = await classService.getClassMembers(id, userId, options);
    }
    
    return successResponse(res, {
      ...result,
      class_id: id,
      mentorship_enhanced: includeMentorship,
      user_context: {
        user_id: userId,
        converse_id: req.user.converse_id
      }
    }, 'Class members retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassMembers error:', error);
    return errorResponse(res, error);
  }
};

/**
 * GET /api/classes/recommendations - Get class recommendations
 */
export const getClassRecommendations = async (req, res) => {
  try {
    const userId = req.user.id;
    const options = {
      limit: parseInt(req.query.limit) || 6
    };

    const result = await classService.getAvailableClasses(userId, options);
    
    return successResponse(res, {
      data: result.data,
      user_id: userId
    }, 'Class recommendations retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassRecommendations error:', error);
    return errorResponse(res, error);
  }
};

// =============================================================================
// USER PROGRESS AND ACTIVITY
// =============================================================================

/**
 * GET /api/classes/my-progress - Get user's progress across all classes
 */
export const getUserProgress = async (req, res) => {
  try {
    const userId = req.user.id;

    const result = await classService.getUserClasses(userId, { limit: 100 });

    const progressData = {
      total_classes: result.data.length,
      active_classes: result.data.filter(c => c.membership_status === 'active').length,
      moderator_classes: result.data.filter(c => c.role_in_class === 'moderator').length,
      member_since: result.data.length > 0 ? 
        Math.min(...result.data.map(c => new Date(c.joinedAt))) : null
    };

    return successResponse(res, {
      data: { progress: progressData },
      user_id: userId
    }, 'User progress retrieved successfully');

  } catch (error) {
    console.error('‚ùå getUserProgress error:', error);
    return errorResponse(res, error);
  }
};

/**
 * GET /api/classes/my-activity - Get user's recent class activity
 */
export const getUserActivity = async (req, res) => {
  try {
    const userId = req.user.id;

    const result = await classService.getUserClasses(userId, { limit: 5 });

    const activityData = {
      recent_joins: result.data.map(cls => ({
        class_name: cls.class_name,
        joinedAt: cls.joinedAt,
        type: 'join'
      })),
      total_activities: result.data.length
    };

    return successResponse(res, {
      data: { activity: activityData },
      user_id: userId
    }, 'User activity retrieved successfully');

  } catch (error) {
    console.error('‚ùå getUserActivity error:', error);
    return errorResponse(res, error);
  }
};

// =============================================================================
// CLASS CONTENT AND INTERACTION
// =============================================================================

/**
 * GET /api/classes/:id/content - Get class content
 */
export const getClassContent = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const options = {
      page: parseInt(req.query.page) || 1,
      limit: parseInt(req.query.limit) || 20,
      content_type: req.query.content_type,
      sort_by: req.query.sort_by || 'createdAt',
      sort_order: req.query.sort_order || 'DESC'
    };

    const result = await classService.getClassContent(id, userId, options);
    
    return successResponse(res, result, 'Class content retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassContent error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/:id/announcements - Get class announcements
 */
export const getClassAnnouncements = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const options = {
      page: parseInt(req.query.page) || 1,
      limit: parseInt(req.query.limit) || 20,
      announcement_type: req.query.announcement_type || 'all',
      is_active: req.query.is_active !== 'false',
      sort_by: req.query.sort_by || 'createdAt',
      sort_order: req.query.sort_order || 'DESC'
    };

    const result = await classService.getClassAnnouncements(id, userId, options);
    
    return successResponse(res, result, 'Class announcements retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassAnnouncements error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * POST /api/classes/:id/feedback - Submit class feedback
 */
export const submitClassFeedback = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const feedbackData = {
      rating: req.body.rating,
      feedback_text: req.body.feedback_text,
      feedback_type: req.body.feedback_type || 'general',
      session_id: req.body.session_id,
      is_anonymous: req.body.is_anonymous || false
    };

    const result = await classService.submitClassFeedback(userId, id, feedbackData);
    
    return successResponse(res, { data: result }, result.message, 201);

  } catch (error) {
    console.error('‚ùå submitClassFeedback error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * POST /api/classes/:id/attendance - Mark attendance
 */
export const markAttendance = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const options = {
      session_id: req.body.session_id,
      status: req.body.status || 'present',
      notes: req.body.notes,
      check_in_time: req.body.check_in_time || new Date(),
      location: req.body.location
    };

    const result = await classService.markClassAttendance(userId, id, options);
    
    return successResponse(res, { data: result }, result.message, 201);

  } catch (error) {
    console.error('‚ùå markAttendance error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/:id/schedule - Get class schedule
 */
export const getClassSchedule = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const options = {
      start_date: req.query.start_date,
      end_date: req.query.end_date,
      session_type: req.query.session_type
    };

    const result = await classService.getClassSchedule(id, userId, options);
    
    return successResponse(res, { data: result }, 'Class schedule retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassSchedule error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/:id/progress - Get user's progress in specific class
 */
export const getClassProgress = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    const result = await classService.getClassProgress(userId, id);
    
    return successResponse(res, { data: result }, 'Class progress retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassProgress error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/test - Test endpoint
 */
export const testClassRoutes = async (req, res) => {
  try {
    return successResponse(res, {
      data: {
        route_status: 'operational',
        user_context: req.user ? {
          id: req.user.id,
          username: req.user.username,
          role: req.user.role,
          converse_id: req.user.converse_id
        } : 'no_authentication',
        available_operations: [
          'view classes',
          'join/leave classes', 
          'view members',
          'search classes',
          'track progress',
          'submit feedback',
          'mark attendance',
          'mentorship management'
        ],
        service_layer: 'connected',
        database_layer: 'active'
      }
    }, 'Class routes test completed successfully');

  } catch (error) {
    console.error('‚ùå testClassRoutes error:', error);
    return errorResponse(res, error);
  }
};

// =============================================================================
// MENTORSHIP INTEGRATION WITH CONVERSE ID SYSTEM
// =============================================================================

/**
 * GET /api/classes/:id/mentorship-pairs - Get mentorship pairs within class
 */
export const getClassMentorshipPairs = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    const result = await classService.getClassMentorshipPairs(id, userId);
    
    return successResponse(res, {
      ...result,
      class_id: id,
      user_context: {
        user_id: userId,
        converse_id: req.user.converse_id
      }
    }, 'Class mentorship pairs retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassMentorshipPairs error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 : 
                      error.message.includes('not found') ? 404 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/:id/my-mentorship-status - Get user's mentorship status
 */
export const getUserMentorshipStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    const result = await classService.getUserMentorshipStatus(id, userId);
    
    return successResponse(res, {
      data: result,
      class_id: id,
      user_id: userId,
      converse_id: req.user.converse_id
    }, 'User mentorship status retrieved successfully');

  } catch (error) {
    console.error('‚ùå getUserMentorshipStatus error:', error);
    const statusCode = error.message.includes('not found') ? 404 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * POST /api/classes/:id/request-mentor - Request a mentor within class
 */
export const requestClassMentor = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const requestData = {
      mentee_converse_id: req.user.converse_id,
      class_id: id,
      reason: req.body.reason || 'Requesting mentorship guidance',
      learning_goals: req.body.learning_goals,
      preferred_mentor_type: req.body.preferred_mentor_type || 'any'
    };

    const result = await classService.requestClassMentor(userId, id, requestData);
    
    return successResponse(res, {
      data: result,
      user_context: {
        user_id: userId,
        converse_id: req.user.converse_id
      }
    }, result.message || 'Mentor request submitted successfully', 201);

  } catch (error) {
    console.error('‚ùå requestClassMentor error:', error);
    const statusCode = error.message.includes('already requested') ? 409 :
                      error.message.includes('not found') ? 404 :
                      error.message.includes('Access denied') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * POST /api/classes/:id/accept-mentorship - Accept mentorship within class
 */
export const acceptClassMentorship = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const acceptanceData = {
      mentor_converse_id: req.user.converse_id,
      mentee_converse_id: req.body.mentee_converse_id,
      class_id: id,
      mentorship_type: req.body.mentorship_type || 'general',
      notes: req.body.notes
    };

    const result = await classService.acceptClassMentorship(userId, id, acceptanceData);
    
    return successResponse(res, {
      data: result,
      mentor_context: {
        user_id: userId,
        converse_id: req.user.converse_id
      }
    }, result.message || 'Mentorship accepted successfully', 201);

  } catch (error) {
    console.error('‚ùå acceptClassMentorship error:', error);
    const statusCode = error.message.includes('not eligible') ? 403 :
                      error.message.includes('not found') ? 404 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/:id/stats - Get class statistics
 */
export const getClassStats = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const userId = req.user?.id;

    console.log(`üìä Getting stats for class ${classId}`);

    const result = await classService.getClassStats(classId, userId);

    return successResponse(res, {
      data: result.data
    }, result.message || 'Class stats retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassStats error:', error);
    const statusCode = error.message.includes('not found') ? 404 :
                      error.message.includes('access') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

// =============================================================================
// CLASSROOM VIDEO/LIVE SESSION CONTROLLER FUNCTIONS
// =============================================================================

/**
 * GET /api/classes/:id/classroom/session - Get classroom session data
 */
export const getClassroomSession = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const userId = req.user?.id;

    console.log(`üìπ Getting classroom session for class ${classId} - UPDATED`);

    // For now, return test data for OTU#004001
    if (classId === 'OTU#004001') {
      const sessionData = {
        class_id: classId,
        class_name: 'Sacred Geometry Fundamentals',
        session_id: `session_${classId}_${Date.now()}`,
        title: 'Introduction to Sacred Geometry',
        description: 'Learn the fundamental principles of sacred geometry and its applications in spiritual practice.',
        is_live: false,
        status: 'recorded',
        video_url: 'https://sample-videos.com/zip/10/mp4/SampleVideo_1280x720_1mb.mp4', // Sample video URL
        thumbnail_url: 'https://via.placeholder.com/720x480.png?text=Sacred+Geometry+Class',
        duration: 60, // 1 minute
        session_number: 1,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      return successResponse(res, {
        data: sessionData
      }, 'Classroom session retrieved successfully');
    }

    // For other classes, return "no session" data
    return successResponse(res, {
      data: {
        class_id: classId,
        message: 'No active classroom session for this class',
        status: 'no_session'
      }
    }, 'No active session found');

  } catch (error) {
    console.error('‚ùå getClassroomSession error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * GET /api/classes/:id/classroom/chat - Get classroom chat messages
 */
export const getClassroomChat = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const userId = req.user?.id;

    console.log(`üí¨ Getting classroom chat for class ${classId}`);

    // For now, return sample chat data
    const chatData = [
      {
        id: 1,
        message: 'Welcome to the Sacred Geometry class!',
        author_converse_id: 'OTO#INSTRUCTOR01',
        timestamp: new Date(Date.now() - 300000).toISOString(), // 5 minutes ago
        message_type: 'announcement'
      },
      {
        id: 2,
        message: 'Hello everyone! Excited to learn about sacred geometry.',
        author_converse_id: 'OTO#STUDENT01',
        timestamp: new Date(Date.now() - 240000).toISOString(), // 4 minutes ago
        message_type: 'chat'
      },
      {
        id: 3,
        message: 'Please focus on the geometric patterns we will be discussing.',
        author_converse_id: 'OTO#INSTRUCTOR01',
        timestamp: new Date(Date.now() - 180000).toISOString(), // 3 minutes ago
        message_type: 'instruction'
      }
    ];

    return successResponse(res, {
      data: chatData
    }, 'Classroom chat retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassroomChat error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * POST /api/classes/:id/classroom/chat - Send chat message
 */
export const sendClassroomChatMessage = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const userId = req.user?.id;
    const { message } = req.body;

    console.log(`üí¨ Sending chat message to class ${classId}`);

    if (!message || message.trim().length === 0) {
      return errorResponse(res, new Error('Message cannot be empty'), 400);
    }

    // Create new message
    const newMessage = {
      id: Date.now(),
      message: message.trim(),
      author_converse_id: req.user?.converse_id || 'OTO#UNKNOWN',
      timestamp: new Date().toISOString(),
      message_type: 'chat'
    };

    return successResponse(res, {
      data: newMessage
    }, 'Message sent successfully', 201);

  } catch (error) {
    console.error('‚ùå sendClassroomChatMessage error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * GET /api/classes/:id/classroom/participants - Get classroom participants
 */
export const getClassroomParticipants = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const userId = req.user?.id;

    console.log(`üë• Getting classroom participants for class ${classId}`);

    // Sample participants data
    const participantsData = [
      {
        id: 1,
        converse_id: 'OTO#INSTRUCTOR01',
        name: 'Sacred Geometry Instructor',
        role_in_class: 'Instructor',
        is_online: true,
        joined_at: new Date(Date.now() - 600000).toISOString(), // 10 minutes ago
        avatar_url: 'https://via.placeholder.com/50x50.png?text=I'
      },
      {
        id: 2,
        converse_id: req.user?.converse_id || 'OTO#STUDENT01',
        name: 'Current User',
        role_in_class: 'Student',
        is_online: true,
        joined_at: new Date(Date.now() - 300000).toISOString(), // 5 minutes ago
        avatar_url: 'https://via.placeholder.com/50x50.png?text=S'
      },
      {
        id: 3,
        converse_id: 'OTO#STUDENT02',
        name: 'Fellow Student',
        role_in_class: 'Student',
        is_online: true,
        joined_at: new Date(Date.now() - 420000).toISOString(), // 7 minutes ago
        avatar_url: 'https://via.placeholder.com/50x50.png?text=F'
      }
    ];

    return successResponse(res, {
      data: participantsData
    }, 'Classroom participants retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassroomParticipants error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * POST /api/classes/:id/classroom/attendance - Mark classroom attendance
 */
export const markClassroomAttendance = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const userId = req.user?.id;
    const { session_id } = req.body;

    console.log(`üìÖ Marking classroom attendance for class ${classId}, user ${userId}`);

    // Create attendance record
    const attendanceRecord = {
      class_id: classId,
      user_id: userId,
      converse_id: req.user?.converse_id || 'OTO#UNKNOWN',
      session_id: session_id || `session_${classId}_${Date.now()}`,
      marked_at: new Date().toISOString(),
      attendance_type: 'classroom_session'
    };

    return successResponse(res, {
      data: attendanceRecord
    }, 'Attendance marked successfully', 201);

  } catch (error) {
    console.error('‚ùå markClassroomAttendance error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * POST /api/classes/:id/classroom/sessions - Create classroom session
 */
export const createClassroomSession = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const userId = req.user?.id;
    const {
      session_type,
      video_id,
      title,
      description,
      availability,
      allow_chat = true,
      require_attendance = false
    } = req.body;

    console.log(`üé• Creating classroom session for class ${classId}`);

    const result = await classService.createClassroomSession(
      classId,
      userId,
      {
        session_type,
        video_id,
        title,
        description,
        availability,
        allow_chat,
        require_attendance
      }
    );

    return successResponse(res, result.data, result.message, 201);
  } catch (error) {
    console.error('‚ùå createClassroomSession error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * POST /api/classes/:id/classroom/sessions/:sessionId/join - Join classroom session
 */
export const joinClassroomSession = async (req, res) => {
  try {
    const { id: classId, sessionId } = req.params;
    const userId = req.user?.id;

    console.log(`üë• User ${userId} joining classroom session ${sessionId} in class ${classId}`);

    const result = await classService.joinClassroomSession(classId, sessionId, userId);

    return successResponse(res, result.data, result.message, 200);
  } catch (error) {
    console.error('‚ùå joinClassroomSession error:', error);
    return errorResponse(res, error, 500);
  }
};

// =============================================================================
// VIDEO MANAGEMENT CONTROLLER FUNCTIONS (MEMBER LEVEL REQUIRED)
// =============================================================================

/**
 * POST /api/classes/:id/videos - Upload teaching video for class
 * Requires member level privileges
 */
export const uploadClassVideo = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const userId = req.user.id;
    const videoFile = req.file;

    console.log(`üìπ Uploading video to class ${classId} by user ${userId}`);

    if (!videoFile) {
      return errorResponse(res, new Error('No video file provided'), 400);
    }

    const videoData = {
      title: req.body.title || `Teaching Video - ${new Date().toLocaleDateString()}`,
      description: req.body.description,
      duration: req.body.duration,
      fileSize: videoFile.size,
      maskingEnabled: req.body.maskingEnabled === 'true',
      maskingSettings: req.body.maskingSettings,
      voiceAltered: req.body.voiceAltered === 'true',
      file: videoFile
    };

    const result = await classService.uploadClassVideo(userId, classId, videoData);

    return successResponse(res, {
      data: result
    }, 'Video uploaded successfully', 201);

  } catch (error) {
    console.error('‚ùå uploadClassVideo error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 :
                      error.message.includes('not found') ? 404 :
                      error.message.includes('too large') ? 413 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/:id/videos - Get all videos for class
 */
export const getClassVideos = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const userId = req.user.id;

    const options = {
      page: parseInt(req.query.page) || 1,
      limit: parseInt(req.query.limit) || 20,
      sort_by: req.query.sort_by || 'createdAt',
      sort_order: req.query.sort_order || 'DESC'
    };

    console.log(`üìπ Getting videos for class ${classId}`);

    const result = await classService.getClassVideos(classId, userId, options);

    return successResponse(res, {
      ...result,
      class_id: classId
    }, 'Class videos retrieved successfully');

  } catch (error) {
    console.error('‚ùå getClassVideos error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 :
                      error.message.includes('not found') ? 404 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * DELETE /api/classes/:id/videos/:videoId - Delete class video
 * Requires member level privileges and ownership or moderator role
 */
export const deleteClassVideo = async (req, res) => {
  try {
    const { id: classId, videoId } = req.params;
    const userId = req.user.id;

    console.log(`üóëÔ∏è Deleting video ${videoId} from class ${classId} by user ${userId}`);

    const result = await classService.deleteClassVideo(userId, classId, videoId);

    return successResponse(res, {
      data: result
    }, 'Video deleted successfully');

  } catch (error) {
    console.error('‚ùå deleteClassVideo error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 :
                      error.message.includes('not found') ? 404 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * POST /api/classes/:id/content - Create content for class
 * Supports video, audio, documents, and text content
 * Requires member level privileges
 */
export const createClassContent = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const userId = req.user.id;
    const files = req.files;

    console.log(`üìù Creating content for class ${classId} by user ${userId}`);

    // Extract content data from request
    const contentData = {
      title: req.body.title || 'Untitled Content',
      description: req.body.description,
      content_type: req.body.content_type || 'lesson', // lesson, material, announcement, live_session
      content_text: req.body.content_text,
      is_live: req.body.is_live === 'true',
      scheduled_for: req.body.scheduled_for,
      duration: req.body.duration,
      tags: req.body.tags ? req.body.tags.split(',').map(tag => tag.trim()) : [],
      files: files
    };

    // Validate required fields
    if (!contentData.title.trim()) {
      return errorResponse(res, new Error('Content title is required'), 400);
    }

    if (!['lesson', 'material', 'announcement', 'live_session', 'audio', 'video'].includes(contentData.content_type)) {
      return errorResponse(res, new Error('Invalid content type'), 400);
    }

    const result = await classService.createClassContent(userId, classId, contentData);

    return successResponse(res, {
      data: result
    }, 'Content created successfully', 201);

  } catch (error) {
    console.error('‚ùå createClassContent error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 :
                      error.message.includes('not found') ? 404 :
                      error.message.includes('required') ? 400 : 500;
    return errorResponse(res, error, statusCode);
  }
};

// =============================================================================
// LIVE CLASS SCHEDULING CONTROLLERS (INDUSTRY BEST PRACTICES)
// =============================================================================

/**
 * POST /api/classes/live/schedule - Schedule a new live class
 * Industry workflow: Member schedules ‚Üí Admin approves ‚Üí Audience notified ‚Üí Go live
 */
export const scheduleLiveClass = async (req, res) => {
  try {
    const userId = req.user.id;

    console.log(`üìÖ Scheduling live class by user ${userId}`);

    const scheduleData = {
      title: req.body.title,
      description: req.body.description,
      class_type: req.body.class_type || 'video',
      scheduled_start_time: req.body.scheduled_start_time,
      estimated_duration: parseInt(req.body.estimated_duration) || 60,
      target_audience: req.body.target_audience || 'members',
      target_class_id: req.body.target_class_id,
      notification_preferences: req.body.notification_preferences || { email: true, sms: false },
      streaming_settings: req.body.streaming_settings || { video_quality: 'HD', audio_quality: 'high' },
      special_instructions: req.body.special_instructions
    };

    // Validate required fields
    if (!scheduleData.title || !scheduleData.scheduled_start_time) {
      return errorResponse(res, new Error('Title and scheduled start time are required'), 400);
    }

    const result = await classService.scheduleLiveClass(userId, scheduleData);

    return successResponse(res, {
      data: result
    }, 'Live class scheduled successfully - pending admin approval', 201);

  } catch (error) {
    console.error('‚ùå scheduleLiveClass controller error:', error);
    const statusCode = error.message.includes('Access denied') ? 403 :
                      error.message.includes('30 minutes') ? 400 :
                      error.message.includes('conflicts') ? 409 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/live/my-sessions - Get user's live class sessions
 */
export const getUserLiveClasses = async (req, res) => {
  try {
    const userId = req.user.id;
    const {
      page = 1,
      limit = 20,
      status = 'all',
      include_past = false
    } = req.query;

    console.log(`üìã Getting live classes for user ${userId}`);

    // Import db for simple query
    const { default: db } = await import('../config/db.js');

    let whereClause = 'WHERE lcs.requested_by = ?';
    const queryParams = [userId];

    if (status !== 'all') {
      whereClause += ' AND lcs.status = ?';
      queryParams.push(status);
    }

    if (include_past !== 'true') {
      whereClause += ' AND lcs.scheduled_start_time > NOW()';
    }

    const offset = (page - 1) * limit;

    const liveClasses = await db.query(`
      SELECT
        lcs.*,
        CASE
          WHEN lcs.status = 'pending_approval' THEN 'Pending Admin Approval'
          WHEN lcs.status = 'approved' THEN 'Approved - Notifications Pending'
          WHEN lcs.status = 'scheduled' THEN 'Scheduled - Audience Notified'
          WHEN lcs.status = 'live' THEN 'Currently Live'
          WHEN lcs.status = 'completed' THEN 'Completed'
          WHEN lcs.status = 'rejected' THEN 'Rejected by Admin'
          ELSE lcs.status
        END as status_description,
        TIMESTAMPDIFF(HOUR, NOW(), lcs.scheduled_start_time) as hours_until_start,
        admin_user.username as reviewed_by_username
      FROM live_class_schedules lcs
      LEFT JOIN users admin_user ON lcs.reviewed_by = admin_user.id
      ${whereClause}
      ORDER BY lcs.scheduled_start_time ASC
      LIMIT ? OFFSET ?
    `, [...queryParams, limit, offset]);

    return successResponse(res, {
      data: liveClasses.map(lc => ({
        ...lc,
        notification_preferences: JSON.parse(lc.notification_preferences || '{}'),
        streaming_settings: JSON.parse(lc.streaming_settings || '{}'),
        can_start_now: lc.status === 'scheduled' && lc.hours_until_start <= 0,
        join_url: lc.status === 'live' ? `/live/${lc.session_id}` : null
      })),
      pagination: {
        current_page: parseInt(page),
        total_pages: Math.ceil(liveClasses.length / limit),
        total_records: liveClasses.length,
        per_page: parseInt(limit)
      }
    }, 'Live classes retrieved successfully');

  } catch (error) {
    console.error('‚ùå getUserLiveClasses error:', error);
    return errorResponse(res, error);
  }
};

/**
 * POST /api/classes/live/start/:sessionId - Start live class session
 */
export const startLiveClassSession = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const userId = req.user.id;

    console.log(`üî¥ Starting live session ${sessionId} by user ${userId}`);

    const result = await classService.startLiveClassSession(sessionId, userId);

    return successResponse(res, {
      data: result
    }, 'Live class session started successfully');

  } catch (error) {
    console.error('‚ùå startLiveClassSession error:', error);
    const statusCode = error.message.includes('not found') ? 404 :
                      error.message.includes('Only the scheduled instructor') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

// =============================================================================
// LIVE CLASS ADMIN CONTROLLERS
// =============================================================================

/**
 * GET /api/classes/live/admin/dashboard - Admin dashboard
 */
export const getLiveClassAdminDashboard = async (req, res) => {
  try {
    const userId = req.user.id;

    console.log(`üìä Getting live class admin dashboard for user ${userId}`);

    const dashboard = await classService.getLiveClassAdminDashboard(userId);

    return successResponse(res, {
      data: dashboard
    }, 'Live class admin dashboard retrieved successfully');

  } catch (error) {
    console.error('‚ùå getLiveClassAdminDashboard error:', error);
    const statusCode = error.message.includes('Admin privileges required') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/live/admin/pending - Get pending approvals
 */
export const getPendingLiveClassApprovals = async (req, res) => {
  try {
    const userId = req.user.id;

    console.log(`üìã Getting pending live class approvals for admin ${userId}`);

    const options = {
      page: parseInt(req.query.page) || 1,
      limit: parseInt(req.query.limit) || 20,
      sort_by: req.query.sort_by || 'created_at',
      sort_order: req.query.sort_order || 'DESC',
      class_type: req.query.class_type,
      priority: req.query.priority || 'all'
    };

    const result = await classService.getPendingLiveClassApprovals(userId, options);

    return successResponse(res, {
      data: result.data,
      pagination: result.pagination,
      summary: result.summary
    }, 'Pending live class approvals retrieved successfully');

  } catch (error) {
    console.error('‚ùå getPendingLiveClassApprovals error:', error);
    const statusCode = error.message.includes('Admin privileges required') ? 403 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * PUT /api/classes/live/admin/review/:scheduleId - Review schedule
 */
export const reviewLiveClassSchedule = async (req, res) => {
  try {
    const { scheduleId } = req.params;
    const userId = req.user.id;

    console.log(`üîç Reviewing live class schedule ${scheduleId} by admin ${userId}`);

    const approvalData = {
      decision: req.body.decision,
      admin_notes: req.body.admin_notes,
      modifications: req.body.modifications || {},
      notification_message: req.body.notification_message
    };

    if (!['approve', 'reject', 'modify'].includes(approvalData.decision)) {
      return errorResponse(res, new Error('Invalid decision. Must be: approve, reject, or modify'), 400);
    }

    const result = await classService.approveLiveClassSchedule(userId, parseInt(scheduleId), approvalData);

    // If approved, trigger notifications
    if (approvalData.decision === 'approve' && result.notification_ready) {
      try {
        const notificationResult = await classService.sendLiveClassNotifications(parseInt(scheduleId));
        result.notifications = notificationResult;
      } catch (notificationError) {
        console.error('‚ùå Failed to send notifications:', notificationError);
        result.notification_warning = 'Approval successful but notifications failed';
      }
    }

    return successResponse(res, {
      data: result
    }, `Live class schedule ${approvalData.decision}d successfully`);

  } catch (error) {
    console.error('‚ùå reviewLiveClassSchedule error:', error);
    const statusCode = error.message.includes('Admin privileges required') ? 403 :
                      error.message.includes('not found') ? 404 :
                      error.message.includes('Cannot') ? 400 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * POST /api/classes/live/admin/notify/:scheduleId - Trigger notifications
 */
export const triggerLiveClassNotifications = async (req, res) => {
  try {
    const { scheduleId } = req.params;
    const userId = req.user.id;

    console.log(`üìß Triggering notifications for schedule ${scheduleId} by admin ${userId}`);

    // Verify admin privileges
    const { default: db } = await import('../config/db.js');
    const adminCheck = await db.query(`SELECT role FROM users WHERE id = ?`, [userId]);

    if (!adminCheck.length || !['admin', 'super_admin'].includes(adminCheck[0].role)) {
      return errorResponse(res, new Error('Admin privileges required'), 403);
    }

    const notificationOptions = {
      custom_message: req.body.custom_message,
      force_resend: req.body.force_resend || false
    };

    const result = await classService.sendLiveClassNotifications(parseInt(scheduleId), notificationOptions);

    return successResponse(res, {
      data: result
    }, 'Live class notifications sent successfully');

  } catch (error) {
    console.error('‚ùå triggerLiveClassNotifications error:', error);
    const statusCode = error.message.includes('not found') ? 404 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * POST /api/classes/live/admin/control/:sessionId - Admin control session
 */
export const adminControlLiveSession = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { action } = req.body;
    const userId = req.user.id;

    console.log(`üéõÔ∏è Admin ${action} live session ${sessionId} by admin ${userId}`);

    // Verify admin privileges
    const { default: db } = await import('../config/db.js');
    const adminCheck = await db.query(`SELECT role FROM users WHERE id = ?`, [userId]);

    if (!adminCheck.length || !['admin', 'super_admin'].includes(adminCheck[0].role)) {
      return errorResponse(res, new Error('Admin privileges required'), 403);
    }

    let result;

    if (action === 'start') {
      result = await classService.startLiveClassSession(sessionId, userId);
    } else if (action === 'stop') {
      await db.query(`
        UPDATE live_class_schedules
        SET status = 'completed', actual_end_time = NOW()
        WHERE session_id = ?
      `, [sessionId]);

      await db.query(`
        UPDATE live_class_sessions
        SET status = 'completed', ended_at = NOW()
        WHERE session_id = ?
      `, [sessionId]);

      result = {
        session_id: sessionId,
        action: 'stopped',
        stopped_by: userId,
        stopped_at: new Date()
      };
    }

    return successResponse(res, {
      data: result
    }, `Live session ${action}ed successfully`);

  } catch (error) {
    console.error('‚ùå adminControlLiveSession error:', error);
    return errorResponse(res, error);
  }
};

// ===============================================
// VIDEO SESSION CONTROLLER FUNCTIONS
// ===============================================

/**
 * POST /api/classes/:id/video-sessions - Create video session
 */
export const createVideoSessionController = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const userId = req.user.id;

    const sessionData = {
      classId,
      title: req.body.title,
      description: req.body.description,
      instructorId: userId,
      sessionType: req.body.sessionType || 'recorded',
      scheduledStart: req.body.scheduledStart,
      createdBy: userId
    };

    const result = await classService.createVideoSession(sessionData);
    return successResponse(res, result, result.message, 201);

  } catch (error) {
    console.error('‚ùå createVideoSession controller error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * GET /api/classes/video-sessions/:sessionId - Get video session
 */
export const getVideoSessionController = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const result = await classService.getVideoSession(sessionId);
    return successResponse(res, result, result.message);

  } catch (error) {
    console.error('‚ùå getVideoSession controller error:', error);
    const statusCode = error.message.includes('not found') ? 404 : 500;
    return errorResponse(res, error, statusCode);
  }
};

/**
 * GET /api/classes/:id/video-sessions - Get class video sessions
 */
export const getClassVideoSessions = async (req, res) => {
  try {
    const { id: classId } = req.params;
    const result = await classService.getClassVideoSessions(classId);
    return successResponse(res, result, result.message);

  } catch (error) {
    console.error('‚ùå getClassVideoSessions controller error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * POST /api/classes/video-sessions/:sessionId/join - Join video session
 */
export const joinVideoSession = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const userId = req.user.id;
    const result = await classService.joinVideoSession(sessionId, userId);
    return successResponse(res, result, result.message);

  } catch (error) {
    console.error('‚ùå joinVideoSession controller error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * POST /api/classes/video-sessions/:sessionId/leave - Leave video session
 */
export const leaveVideoSession = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const userId = req.user.id;
    const result = await classService.leaveVideoSession(sessionId, userId);
    return successResponse(res, result, result.message);

  } catch (error) {
    console.error('‚ùå leaveVideoSession controller error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * GET /api/classes/video-sessions/:sessionId/participants - Get session participants
 */
export const getSessionParticipants = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const result = await classService.getSessionParticipants(sessionId);
    return successResponse(res, result, result.message);

  } catch (error) {
    console.error('‚ùå getSessionParticipants controller error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * POST /api/classes/video-sessions/:sessionId/chat - Send chat message
 */
export const sendSessionChatMessage = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const userId = req.user.id;
    const { message } = req.body;
    const username = req.user.username || `User ${userId}`;

    const result = await classService.sendSessionChatMessage(sessionId, userId, message, username);
    return successResponse(res, result, result.message);

  } catch (error) {
    console.error('‚ùå sendSessionChatMessage controller error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * GET /api/classes/video-sessions/:sessionId/chat - Get chat messages
 */
export const getSessionChatMessages = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const limit = parseInt(req.query.limit) || 50;
    const result = await classService.getSessionChatMessages(sessionId, limit);
    return successResponse(res, result, result.message);

  } catch (error) {
    console.error('‚ùå getSessionChatMessages controller error:', error);
    return errorResponse(res, error, 500);
  }
};

/**
 * POST /api/classes/video-sessions/:sessionId/attendance - Mark session attendance
 */
export const markVideoSessionAttendanceController = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const userId = req.user.id;
    const attendanceStatus = req.body.status || 'present';

    const result = await classService.markVideoSessionAttendance(sessionId, userId, attendanceStatus);
    return successResponse(res, result, result.message);

  } catch (error) {
    console.error('‚ùå markVideoSessionAttendance controller error:', error);
    return errorResponse(res, error, 500);
  }
};

// =============================================================================
// EXPORT ALL CONTROLLER FUNCTIONS
// =============================================================================

export default {
  // Core Operations
  getAllClasses,
  getClassById,
  getUserClasses,
  joinClass,
  leaveClass,
  getClassMembers,
  getClassRecommendations,
  
  // Progress & Activity
  getUserProgress,
  getUserActivity,
  
  // Content & Interaction
  getClassContent,
  getClassAnnouncements,
  submitClassFeedback,
  markAttendance,
  getClassSchedule,
  getClassProgress,
  getClassStats,
  
  // Mentorship Integration
  getClassMentorshipPairs,
  getUserMentorshipStatus,
  requestClassMentor,
  acceptClassMentorship,

  // Classroom Video/Live Sessions
  getClassroomSession,
  getClassroomChat,
  sendClassroomChatMessage,
  getClassroomParticipants,
  markClassroomAttendance,

  // Classroom Session Management
  createClassroomSession,
  joinClassroomSession,

  // Video Management (Member Level Required)
  uploadClassVideo,
  getClassVideos,
  deleteClassVideo,

  // Video Session Management
  createVideoSessionController,
  getVideoSessionController,
  getClassVideoSessions,
  joinVideoSession,
  leaveVideoSession,
  getSessionParticipants,
  sendSessionChatMessage,
  getSessionChatMessages,
  markVideoSessionAttendanceController,

  // Content Creation (Member Level Required)
  createClassContent,

  // Live Class Scheduling (Member Level Required)
  scheduleLiveClass,
  getUserLiveClasses,
  startLiveClassSession,

  // Live Class Admin (Admin Only)
  getLiveClassAdminDashboard,
  getPendingLiveClassApprovals,
  reviewLiveClassSchedule,
  triggerLiveClassNotifications,
  adminControlLiveSession,

  // System
  testClassRoutes,

  // Utilities (for internal use)
  successResponse,
  errorResponse
};

