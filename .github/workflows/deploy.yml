name: Deploy to AWS

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_API: ikoota-api
  ECR_REPOSITORY_CLIENT: ikoota-client

jobs:
  test-and-build:
    name: Test and Build
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: |
          ikootaapi/package-lock.json
          ikootaclient/package-lock.json

    # Test and build API
    - name: Install API dependencies
      working-directory: ./ikootaapi
      run: npm ci

    - name: Lint API code
      working-directory: ./ikootaapi
      run: npm run lint || echo "No lint script found, skipping..."

    - name: Test API
      working-directory: ./ikootaapi
      run: npm test || echo "No test script found, skipping..."

    # Test and build Client
    - name: Install Client dependencies
      working-directory: ./ikootaclient
      run: npm ci

    - name: Lint Client code
      working-directory: ./ikootaclient
      run: npm run lint

    - name: Build Client
      working-directory: ./ikootaclient
      run: npm run build

    # Security scanning
    - name: Run security audit on API
      working-directory: ./ikootaapi
      run: npm audit --audit-level=high || true

    - name: Run security audit on Client  
      working-directory: ./ikootaclient
      run: npm audit --audit-level=high || true

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: test-and-build
    if: github.ref == 'refs/heads/main'
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push API image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "üî® Building API image with SHA: $IMAGE_TAG"
        docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG ./ikootaapi
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_API:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_API:latest

    - name: Build and push Client image (staging)
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "üî® Building CLIENT image for staging with SHA: $IMAGE_TAG"
        docker build --no-cache --build-arg ENVIRONMENT=staging -t $ECR_REGISTRY/$ECR_REPOSITORY_CLIENT:$IMAGE_TAG-staging ./ikootaclient
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY_CLIENT:$IMAGE_TAG-staging $ECR_REGISTRY/$ECR_REPOSITORY_CLIENT:latest-staging
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_CLIENT:$IMAGE_TAG-staging
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_CLIENT:latest-staging

    - name: Deploy to ECS Staging
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Skip staging task definition updates - use simple force deployment for now
        echo "üöÄ Forcing staging deployments with latest images..."

        # Update ECS services with force new deployment (will use latest image tags)
        aws ecs update-service \
          --cluster ikoota-staging \
          --service ikoota-api-staging \
          --force-new-deployment || echo "‚ö†Ô∏è Staging API service update failed, continuing..."

        aws ecs update-service \
          --cluster ikoota-staging \
          --service ikoota-client-staging \
          --force-new-deployment || echo "‚ö†Ô∏è Staging CLIENT service update failed, continuing..."

    - name: Wait for deployment
      run: |
        # Use shorter timeout to avoid GitHub Actions timeout
        timeout 600 aws ecs wait services-stable \
          --cluster ikoota-staging \
          --services ikoota-api-staging ikoota-client-staging || echo "Services may still be stabilizing but continuing..."

    - name: Run health checks
      run: |
        # Wait for services to be healthy
        sleep 60
        
        # Check API health through ALB (staging uses same ALB, different target group)
        curl -f http://api.staging.ikoota.com/api/health || exit 1
        
        # Check Client health  
        curl -f http://staging.ikoota.com/ || exit 1

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Client image (production)
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "üî® Building CLIENT image for production with SHA: $IMAGE_TAG"
        docker build --no-cache --build-arg ENVIRONMENT=production -t $ECR_REGISTRY/$ECR_REPOSITORY_CLIENT:$IMAGE_TAG-production ./ikootaclient

        # Verify the build contains new code by checking build timestamp
        echo "üîç Verifying new build..."
        docker run --rm $ECR_REGISTRY/$ECR_REPOSITORY_CLIENT:$IMAGE_TAG-production find /usr/share/nginx/html -name "index-*.js" -exec stat {} \;

        docker tag $ECR_REGISTRY/$ECR_REPOSITORY_CLIENT:$IMAGE_TAG-production $ECR_REGISTRY/$ECR_REPOSITORY_CLIENT:latest-production

        echo "üì§ Pushing images to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_CLIENT:$IMAGE_TAG-production
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_CLIENT:latest-production

        echo "‚úÖ Production image build and push completed: $IMAGE_TAG-production"

    - name: Deploy to ECS Production
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Update task definition with new image using simple force deployment
        aws ecs update-service \
          --cluster ikoota-production \
          --service ikoota-api-production \
          --force-new-deployment

        aws ecs update-service \
          --cluster ikoota-production \
          --service ikoota-client-production \
          --force-new-deployment

    - name: Wait for production deployment
      run: |
        # Use shorter timeout to avoid GitHub Actions timeout
        timeout 600 aws ecs wait services-stable \
          --cluster ikoota-production \
          --services ikoota-api-production ikoota-client-production || echo "Services may still be stabilizing but continuing..."

    - name: Run production health checks
      run: |
        sleep 60
        # Test HTTPS API endpoint through frontend nginx proxy (correct architecture)
        curl -f https://www.ikoota.com/api/health || exit 1
        # Test HTTPS client site on port 443 (default)
        curl -f https://ikoota.com/ || exit 1
        # Also test www subdomain
        curl -f https://www.ikoota.com/ || exit 1

    - name: Notify deployment success
      if: success()
      run: |
        echo "üöÄ Production deployment successful!"
        echo "üîê API: https://www.ikoota.com/api/health (through nginx proxy)"
        echo "üîê Client: https://ikoota.com"
        echo "üîê Client (www): https://www.ikoota.com"
        echo "üîì Staging: http://staging.ikoota.com (for development)"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: failure()
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Rollback ECS services
      run: |
        echo "üîÑ Rolling back to previous deployment..."
        
        # Get previous task definition ARN
        PREV_TASK_DEF=$(aws ecs describe-services \
          --cluster ikoota-production \
          --services ikoota-api-production \
          --query 'services[0].deployments[1].taskDefinition' \
          --output text)
        
        # Rollback to previous version
        aws ecs update-service \
          --cluster ikoota-production \
          --service ikoota-api-production \
          --task-definition $PREV_TASK_DEF